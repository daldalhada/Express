# Node 내장 기능 (1)

<br>

## 1. Module 

```javascript

const odd = '홀수';
const even = '짝수';

module.exports = {
    odd,            // 원래는 odd: odd
    even,
};

```

```javascript

const value = require('./3-1(1)');
console.log(value);     // {odd: '홀수', even: '짝수'}

const {odd, even} = require('./3-1(1)');
console.log(odd, even); // 홀수 짝수

function checkOddOrEven(number) {
    if(number % 2) {
        return odd;
    } else {
        return even;
    }
}

module.exports = checkOddOrEven;
```

```javascript

const { odd, even } = require('./3-1(1)');
const checkNumber = require('./3-1(2)');

function checkStringOddOrEven(str) {
    if(str.length % 2) {
        return odd;
    } else {
        return even;
    }
}

console.log(checkNumber(11));
console.log(checkStringOddOrEven('daldalhada'));

```

<br>

    - module.exports를 사용하여 객체나 함수를 export 할 수 있음
    - require를 사용하여 다른 모듈의 객체나 함수를 import 할 수 있음
    - 불필요한 코드의 중복을 방지할 수 있는 장점이 있음

<br>

    - [참고] ES2015 모듈(자바스크립트 자체 모듈 시스템 문법)
    - Node 내장 기능과 자바스크립트 모듈 기능 둘 다 사용가능함
    - 하지만, 두 개의 기능이 일대일로 대응하는 것은 아님
  
```javascript

import {odd, even} from './3-1(1)';

funtcion checkOddOrEven(num) {
    // 생략
}

export default checkOddOrEven


```

<br>


***

<br>

## 2. global

<br>


```javascript

module.exports = () => global.message;

```

```javascript

const A = require('./3-2(1)');

global.message = '안녕하세요';
console.log(A());       // 안녕하세요

```

<br>

    - 브라우저의 window 같은 역할
    - 모든 파일에서 접근 가능
    - window 처럼 생략 가능(console, global, setTimeout 모두 global 속성)

<br>


***

<br>

## 3. Timer

<br>

### 실행 결과는?

<br>

```javascript

const timeout = setTimeout(() => {
    console.log('1.5초 후에 실행');
}, 1500);

const interval = setInterval(() => {
    console.log('1초마다 반복 실행');
}, 1000);

const timeout2 = setTimeout(() => {
    console.log('실행되지 않습니다.');
}, 3000);

setTimeout(() => {
    clearTimeout(timeout2);
    clearInterval(interval);
}, 2500);

const immediate = setImmediate(() => {
    console.log('즉시 실행');
});

const immediate2 = setImmediate(() => {
    console.log('실행되지 않습니다.');
});

clearImmediate(immediate2);

```

<br>

    - setTimeout(콜백함수, 밀리초): 주어진 밀리초 이후에 콜백 함수 실행
    - setInterval(콜백함수, 밀리초): 주어진 밀리초마다 콜백함수를 반복 실행
    - setImmediate(콜백함수): 콜백함수를 즉시 실행

<br>

    - clearTimeout(아이디): setTimeout을 취소
    - clearInterval(아이디): setIntalval을 취소
    - clearImmediate(아이디): setImmediate를 취소

<br>

![타이머 실행 결과](https://github.com/daldalhada/Express/blob/main/image/3/3-1/Node1.PNG)

<br>

***

<br>

## 8. async/await

<br>


```javascript

function findAndSaveUser(Users) {
    Users.findOne({})
        .then((user) => {
            user.name = 'JS';
            return user.svae();
        })
        .then((user) => {
            return Users.findOne({ gender: 'm' });
        })
        .then((user) => {
            //생략
        })
        .catch((err) => {
            console.log(err);
        })
}

```

<br>

    - 위의 코드도 Callback Hell처럼 then이 쌓이는 Promise Hell이 발생함
    - async/await을 도입해서 코드를 간결하게 할 수 있음
    - ※ async/await도 Promise이기 때문에 return 값이 존재하면 then을 사용해야 함


<br>

```javascript

async function findAndSaveUser(Users) {
    let user = await Users.findOne({});
    user.name = 'JS';
    user = await user.save();
    user = await Users.findOne({ gender: 'm' });
    //생략
}

```

<br>

    - 변수 = await Promise; 인 경우 Promise가 resolve딘 값이 변수에 저장
      (결과값 = then Promise)
    - 변수 await 값; 인 경우 그 값이 변수에 저장
    - await이 then 역할을 함
    - 단, async/await은 Promise의 reject를 처리하는 부분이 없어 try/catch문을 사용함


<br>

```javascript

const promise1 = Promise.resolve('성공1');
const promise2 = Promise.resolve('성공2');

(async () => {
    for await (promise of [promise1, promise2]) {
        console.log(promise);
    }
})();

```

<br>

    - Promise.all 처럼 for await(변수 of Promise 배열)을 지원

<br>

***

<br>