# 채팅방 만들기

<br>

## 1. 구조

<br>

    - 필요 패키지 설치 후 스키마 작성
    - npm i mongoose multer axios color-hash
    - color-hash는 익명 닉네임에 컬러를 줄 때 사용, 랜덤 번호 부여
    - chat, room에 관한 스키마 작성
    - .env 파일에 ID, PASSWORD를 저장한 뒤 익스프레스(app.js)와 스키마(shemas/index.js) 연결

<br>

***

<br>

## 2. 네임스페이스와 방

<br>

```javascript

const SocketIO = require('socket.io');

module.exports = (server, app) => {
  const io = SocketIO(server, { path: '/socket.io' });  // 서버 생성
  app.set('io', io);    // 변수처럼 사용(req.app.get('io'))
  const room = io.of('/room');      // 네임스페이스
  const chat = io.of('/chat');

  room.on('connection', (socket) => {
    console.log('room 네임스페이스에 접속');
    socket.on('disconnect', () => {
      console.log('room 네임스페이스 접속 해제');
    });
  });

  chat.on('connection', (socket) => {
    console.log('chat 네임스페이스에 접속');
    const req = socket.request;
    const { headers: { referer } } = req;
    const roomId = referer      // 주소에서 roomId를 추출
      .split('/')[referer.split('/').length - 1]
      .replace(/\?.+/, '');
    socket.join(roomId);

    socket.on('disconnect', () => {
      console.log('chat 네임스페이스 접속 해제');
      socket.leave(roomId);
    });
  });
};

```

<br>

    - const io = SocketIO(server, { path: '/socket.io' }) 서버 생성 시 프론트와 path 같에 설정
    - app.set('io', io)은 Express의 변수처럼 사용(req.app.get('io'))
    - 네임스페이스를 io.of로 받음
    - sokcetIO는 join과 leave를 제공 
    - sokcetIO는 계층 구조를 가짐 io > namespace > room
      (ws 모듈에서는 전체 사용자가 실시간 소통을 했다면 socketIO는 계층별로 소통을 구분)

<br>

```javascript

// routes/index.js

router.post('/room', async (req, res, next) => {
  try {
    const newRoom = await Room.create({
      title: req.body.title,
      max: req.body.max,
      owner: req.session.color,       // 방장도 색깔로 구별
      password: req.body.password,
    });
    const io = req.app.get('io');
    io.of('/room').emit('newRoom', newRoom);
    res.redirect(`/room/${newRoom._id}?password=${req.body.password}`);
  } catch (error) {
    console.error(error);
    next(error);
  }
});

router.get('/room/:id', async (req, res, next) => {
  try {
    const room = await Room.findOne({ _id: req.params.id });
    const io = req.app.get('io');
    if (!room) {
      return res.redirect('/?error=존재하지 않는 방입니다.');
    }
    if (room.password && room.password !== req.query.password) {
      return res.redirect('/?error=비밀번호가 틀렸습니다.');
    }
    const { rooms } = io.of('/chat').adapter;
    if (rooms && rooms[req.params.id] && room.max <= rooms[req.params.id].length) {
      return res.redirect('/?error=허용 인원이 초과하였습니다.');
    }
    return res.render('chat', {
      room,
      title: room.title,
      chats: [],
      user: req.session.color,
    });
  } catch (error) {
    console.error(error);
    return next(error);
  }
});

router.delete('/room/:id', async (req, res, next) => {
  try {
    await Room.remove({ _id: req.params.id });
    await Chat.remove({ room: req.params.id });
    res.send('ok');
    // 방에서 마지막으로 나간 사람은 emit이 전달이 안되어서 setTimeout() 설정
    setTimeout(() => {
      req.app.get('io').of('/room').emit('removeRoom', req.params.id);
    }, 2000);       
  } catch (error) {
    console.error(error);
    next(error);
  }
});

module.exports = router;

```

<br>

    - io.of('/room').emit('newRoom', newRoom): room이라는 네임스페이스에 접속된 사용자들에게 새 방에 대한 정보가 전달
    - const { rooms } = io.of('/chat').adapter: 방 목록들이 담겨 있음
    - rooms[req.params.id]: 방 목록들 중 id에 해당하는 방

<br>

***

<br>

## 3. 웹소켓 미들웨어

<br>

    - 

<br>

```HTML



```

<br>

    - 

<br>

```javascript



```

<br>

    - 

<br>

***

<br>

## 4. 채팅, GIF 주고받기

<br>

    - 

<br>

```HTML



```

<br>

    - 

<br>

```javascript



```

<br>

    - 

<br>

***

<br>